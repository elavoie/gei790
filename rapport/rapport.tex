\documentclass[12pt,english,frenchb,letterpaper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsfonts,textcomp}
\usepackage{color}
\usepackage{calc}
\usepackage{verbatim}
\usepackage{longtable}
\geometry{verbose, letterpaper,tmargin=3cm,bmargin=3cm,lmargin=3cm,rmargin=3cm}
\usepackage[french]{babel}


% Custom commands for the report
\newcommand{\action}[3] {
\begin{tabbing}
\it{Action}\=\it{(#1)},\\
\> PRECOND: 
     #2 
     \\
\> EFFECT: \it{#3} .\\
\end{tabbing}}



\begin{document}
\thispagestyle{empty}
\begin{center}
{\large\em GEI790:  Intelligence Artificielle formelle}
\vfill
Rapport de l'App 1\\
présenté professorale de S8\\
\vfill
par:\\
Alexandre Malo\hspace{2cm} 05 659 076\\
Erick Lavoie\hspace{2cm} 05 646 456\\
\vfill
Date: \today
\end{center}

\newpage
\onehalfspacing


\tableofcontents

\newpage


\section{Introduction}
% Alex
% 0.5 page

\section{Recommandation et justification de la technique de planification}
% Erick
% 3 pages
L'analyse des différentes techniques de planification a permis de faire ressortir les éléments suivants.  Cependant, étant donné que le choix de la technique de planification est indépendant du choix de la technique de recherche qui l'implémente, ces deux sujets seront traités séparément.

\subsection{Techniques de planification}
Dans les deux cas,il s'agit de trouver une séquence d'action qui permettent d'atteindre un but. Dans le cas de la planification de la recherche par espace d'état, la recherche s'effectue sur l'état de l'environnement de jeu alors que dans le cas de la planification partiellement ordonnée, la recherche s'effectue sur l'environnement d'actions, c'est-à-dire les actions et leur dépendances mutuelles. 

\subsubsection{Planification par recherche d'espace d'état}

La planification par recherche d'espace d'état est la plus simple à mettre en oeuvre puisqu'elle est conceptuellement très similaire au comportement de l'agent dans la situation réelle.  Il s'agit en quelque sorte d'essayer différent plan possible et d'observer l'évolution de l'environnement pour chacun de ces plans jusqu'à ce que l'on obtienne l'état désiré.  Il est possible de faire la recherche par chaînage avant ou arrière en s'appuyant sur les préconditions et les effets des différentes actions possibles.

Il a été constaté que le chaînage arrière peut éliminer, pour certaines classes de problèmes, l'exploration de branches dans l'arbre de recherche qui ne mènent pas à la solution.  Cependant, dans le cas du jeu \it{BlockBlitz}, la difficulté de spécifier complètement et adéquatement la configuration finale de l'environnement de jeu pour atteindre le but ``Avoir un bloc'' rend très difficile l'application du chaînage arrière.

Le chaînage avant est plus aisé dans notre cas puisque la situation initiale du point de vue de l'arbre de recherche est une situation complètement connue puisque l'environnement de jeu est complètement spécifié et passé au joueur à chaque tour de jeu.

Finalement, dans le cas de la recherche par espace d'état, la recherche d'un heuristique valide dans le cas d'un but composé de plusieurs conditions demande un peu de fignolage car il faut toujours s'assurer que l'heuristique ne surestime pas le coût d'une action.  Pour cela, il est possible d'appliquer l'hypothèse de l'indépendance des sous-buts ou de relâcher les conditions du problème.  Comme le but choisi pour l'intelligence du joueur était unique, nous ne nous sommes pas attardé davantage sur cette question.

\subsubsection{Planification partiellement ordonnée}

La planification partiellement ordonnée est une technique un peu plus sophistiquée, qui tente de manipuler la structure logique du problème pour en dériver un plan.  Ce faisant, il est alors possible de trouver une série d'action et leurs dépendances sans que cette description prescrive une série d'action \it{unique}.  Cela est possible en raisonnant \it{exclusivement} sur les préconditions et les effets des actions, sans tenir compte de l'ensemble de l'environnement.

Cette technique permet une plus grande flexibilité dans l'exécution du plan puisqu'une contrainte inconnue au moment de l'élaboration du plan peut être gérée adéquatement en effectuant un choix parmi les actions possibles au moment de l'exécution.  De plus, l'élaboration du plan pourrait potentiellement être plus efficace si l'espace de recherche sur les actions est moindre que sur les environnement de jeu potentiels.

Cependant, cette technique est plus difficile à appliquer dans le cas où les préconditions ou effets des actions sont représentées avec des variables.  De plus, 

\subsection{Techniques de recherche}

\section{Resultats de tests}
% Alex et Erick
% 3 pages

% Criteres
% - Temps de calcul
% - Utilisation memoire
% - Qualite du plan
% - Complexite de developement

% - Couvrir les algorithmes de recherche informee et non-informee

\section{Representation STRIPS ou ADL des actions possibles de BlockBlitz}
% Erick 
% 1.5 pages
Par soucis de concision et de lisibilité, l'environnement de jeu initial et l'environnement de jeu final seront omis des paramètres, des préconditions et des effets des actions présentées bien qu'ils soient utilisés de fa\c con explicite dans le programme remis.  Pour l'ensemble des actions présentées, nous assumerons un environnement de jeu composé des faits suivants, les multiplicités présentées représentent le nombre de faits distincts du type présenté pouvant être retrouvés dans l'environnement, ex: nbJoueur(N), 1 signifie qu'un seul fait de type nbJoueur est présent dans l'environnement et block(...), 1+ signifie que chaque bloc est représenté par son propre fait et qu'il y en a autant que de blocs.

\begin{center}  \begin{tabular}{@{} ccc @{}}    \hline    Fait & Multiplicité & Signification \\     \hline    NbJoueur(n) & 1 & $n$ est le nombre de joueurs \\     NbBlock(n) & 1 & $n$ est le nombre de blocks \\     NbColonnes(n) & 1 & $n$ est le nombre de colonnes \\     NbRangees(n) & 1 & $n$ est le nombre de rangées \\     Block(id,x,y) & 1+ & $id$ est la valeur du block, \\
                                  && $x$ est la position en selon $x$ \\
                                  && et $y$ est la position selon $y$ \\     Player(id,nom,x,y,blockId) & 1+ & $id$ est l'identifiant unique du joueur \\
                                                              && $nom$ est le nom assigné au joueur \\ 
                                                              && $x$ est la position selon $x$ \\
                                                              && $y$ est la position selon $y$ \\
                                                              && $blockId$ est l'identifiant du bloc possédé par le joueur\\
    Nom(nom) & 1 & $nom$ est le nom du joueur \\     \hline  \end{tabular}\end{center}

En plus de ces faits de base, les prédicats suivants sont utilisés pour faciliter l'expression des préconditions et des effets. \\
\\
Il est nécessaire de traduire la direction en coordonnées. Pour ce faire, le prédicat $Direction(posx,posy,newx,newy,direction)$ est utilisé pour déterminer la nouvelle position du joueur à partir de sa position précédente.  Il y a huit entrées pour chacune des direction.  L'entrée pour la direction $1$ est la suivante, les autres entrées sont laissées comme exercice au lecteur.
\begin{equation*}
	Direction(posx,posy,newx,newy, 1) \Leftarrow newy = posy + 1 \wedge newx = posx 
\end{equation*}

Les deux derniers prédicats sont les suivants.  $Empty(posx,posy)$ assure que la case visée ne contient rien, c'est-à-dire aucun joueur ou bloc, et $Exist(posx,posy)$ valide que la case visée appartient bel et bien à l'environnement, c'est-à-dire qu'elle est contenue dans ses limites.
\begin{eqnarray*}
	Empty(posx,posy) \Leftarrow & \lnot Block(\_,posx,posy)  \wedge \lnot Player(\_,\_,posx,posy,\_) \\
	Exist(posx,posy) \Leftarrow & posx  \geq 0 \wedge posy \geq 0 \\
	                                                    \wedge & NbColonnes(nbColonnes)  \wedge NbRangees(nbRangees) \\
	                                                   \wedge & posx < nbColonnes \wedge posy < nbRangees 
\end{eqnarray*}

Il est alors très aisé d'exprimer les préconditions et les effets de chacune des actions.

\begin{tabbing}
\it{Action}\=\it{(Move(direction))}\=,\\
\> PRECOND: \> $Nom(nom) \wedge Player(id,nom,posx,posy,blockid)$ \\ 
\> \> $  \wedge \ Direction(posx,posy,newx,newy,direction) $ \\
\> \> $   \wedge \ Exist(newx,newy) \wedge Empty(newx,newy) $ \\               
\> EFFECT: \>$ \lnot Player(id,nom,posx,posy,blockid) $ \\
\>  \> $\wedge\ Player(id,nom,newx,newy,blockid)$ .\\
\end{tabbing}

Pour le cas où le joueur ne possède pas de bloc, l'action $take$ est la suivante:

\begin{tabbing}
\it{Action}\=\it{(Take(direction))}\=,\\
\> PRECOND: \> $Nom(nom) \wedge Player(id,nom,posx,posy,0)$ \\ 
\> \> $  \wedge \ Direction(posx,posy,newx,newy,direction) $ \\
\> \> $   \wedge \ Exist(newx,newy) \wedge Block(newblockid,newx,newy) $ \\               
\> EFFECT: \>$ \lnot Player(id,nom,posx,posy,0) $ \\
\>  \> $\wedge\ Player(id,nom,newx,newy,newblockid)$ \\
\> \> $\wedge\ \lnot Block(newblockid,newx,newy) $ .\\
\end{tabbing}

Pour le cas où le joueur possède déjà un bloc, l'action $take$ est plutôt:
\begin{tabbing}
\it{Action}\=\it{(Take(direction))}\=,\\
\> PRECOND: \> $Nom(nom) \wedge Player(id,nom,posx,posy,blockid)$ \\ 
\> \> $  \wedge \ Direction(posx,posy,newx,newy,direction) $ \\
\> \> $   \wedge \ Exist(newx,newy) \wedge Block(newblockid,newx,newy) $ \\               
\> EFFECT: \>$ \lnot Player(id,nom,posx,posy,blockid) $ \\
\>  \> $\wedge\ Player(id,nom,newx,newy,newblockid)$ \\
\> \> $\wedge\ \lnot Block(newblockid,newx,newy) $ \\
\> \> $\wedge\ Block(blockid,newx,newy) $ .\\
\end{tabbing}

\begin{tabbing}
\it{Action}\=\it{(Drop(direction))}\=,\\
\> PRECOND: \> $Nom(nom) \wedge Player(id,nom,posx,posy,blockid)$ \\ 
\> \> $  \wedge \  \lnot Player(id,nom,posx,posy,0) $ \\
\> \> $  \wedge \ Direction(posx,posy,newx,newy,direction) $ \\
\> \> $   \wedge \ Exist(newx,newy) \wedge Empty(newx,newy) $ \\               
\> EFFECT: \>$ \lnot Player(id,nom,posx,posy,blockid) $ \\
\>  \> $\wedge\ Player(id,nom,posx,posy,0)$ \\
\> \> $\wedge\ Block(blockid,newx,newy) $ .\\
\end{tabbing}

Bien que la problématique présente deux cas distincts pour l'attaque, avec la représentation proposée, la même description s'applique dans les deux cas (joueur possède ou non un bloc).  De plus, pour fins de planification, nous allons considérer que l'action réussi toujours.:

\begin{tabbing}
\it{Action}\=\it{(Attack(direction))}\=,\\
\> PRECOND: \> $Nom(nom) \wedge Player(id,nom,posx,posy,blockid)$ \\ 
\> \> $  \wedge \ Direction(posx,posy,newx,newy,direction) $ \\
\> \> $  \wedge \ Player(id2,nom2,newx,newy,blockid2) $ \\
\> \> $  \wedge \ \lnot Player(id2,nom2,newx,newy,0) $ \\
\> \> $ \wedge\ \lnot Block(bid,newx,newy) \wedge \ Exist(newx,newy)$ \\               
\> EFFECT: \>$ \lnot Player(id,nom,posx,posy,blockid) $ \\
\>  \> $\wedge\ Player(id,nom,posx,posy,blockid2)$ \\
\>  \> $\wedge\ \lnot Player(id2,nom2,newx,newy,blockid2)$ \\
\>  \> $\wedge\ Player(id2,nom2,newx,newy,blockid)$ .\\
\end{tabbing}

Finalement, l'action $None$ ne possède aucune précondition et n'a aucun effet sur l'environnement.

\section{Description et une explication du vocabulaire des parties principales de la solution}

\section{Description de parties principales de notre solution}
% Alex
% 1 page

\section{Recommandation de la pertinence des methodes d'algorithme évolué}
% Alex
% 1 page

\section{Conclusion}
% Alex
% 0.5 page

\end{document}