\documentclass[12pt,english,frenchb,letterpaper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsfonts,textcomp}
\usepackage{color}
\usepackage{calc}
\usepackage{verbatim}
\usepackage{longtable}
\geometry{verbose, letterpaper,tmargin=3cm,bmargin=3cm,lmargin=3cm,rmargin=3cm}
\usepackage[french]{babel}


% Custom commands for the report
\newcommand{\action}[3] {
\begin{tabbing}
\textit{Action}\=\textit{(#1)},\\
\> PRECOND: 
     #2 
     \\
\> EFFECT: \textit{#3} .\\
\end{tabbing}}



\begin{document}
\thispagestyle{empty}
\begin{center}
{\large\em GEI790:  Intelligence Artificielle formelle}
\vfill
Rapport de l'App 1\\
présenté à l'équipe professorale de S8\\
\vfill
par:\\
Alexandre Malo\hspace{2cm} 05 659 076\\
Erick Lavoie\hspace{2cm} 05 646 456\\
\vfill
Date: \today
\end{center}

\newpage
\onehalfspacing


\tableofcontents

\newpage


\section{Introduction}
% Alex
% 0.5 page
Ce rapport présente les résultats de recherches pour l'amélioration de l'intelligence de joueur informatisé(\textit{JI}).
Les \textit{JI} qui évoluent entouré de joueur humain font face à un problème critique. En fait ils ne possède pas un intelligence suffisante afin de s'adapter aux multiples situations imprévisible des humains. De plus, les \textit{JI} sont trop prévisible et rendent les jeux rapidement monotone. À ce jour, l'amélioration de \textit{JI} l'élément le plus crutiale pour une évolution saine de la compagnie.

Pour répondre à ce problème, l'ingénieur en chef a déterminé l'utilisation de méthodes d'intelligence artificiel. Les recherches effectué comporte plusieurs volets afin de s'assurer de répondre au besoin réelles de la majorités de nos jeux à plateforme multijoueurs. Voici les études qui ont été réalisées:

\textbf{Méthode de recherches}
\begin{enumerate}
 \item Non informé
 \item Informé avec heuristique
\end{enumerate}

\textbf{Méthode de planification}
\begin{enumerate}
 \item recherche d'espaces d'états
 \item partiellement ordonnée
\end{enumerate}

Avec une représentation de l'intelligence artificiel en logique de première ordre, il devient très facile de réutiliser les algorithmes d'IA pour une multitudes de jeux différents. Avec cette généralisation possible, les recherches on été effectué et testés dans l'environnement de jeux \textit{BlockBlitz}. Cette particularité rend la recherche sur les méthodes de l'intelligence artificiel intéressente afin de réduire le coût de développement de tous les jeux dans la compagnie. L'implémentation des algorithmes ont tous été réaliser à l'aide du language prolog afin d'accélérer le développement. Ce dernier est un langage qui est entièrement basé sur la logique du premier ordre.

Il existe en fait plusieurs autre techniques d'intelligences artificielles que celles présentées précédemments. C'est pourquoi qu en plus de ces recherches, une analyse sommaire de méthodes plus évolué est aussi présenté. À la fin de ce rapport se trouves toutes les recommandations à utiliser pour résouble l'incapacité actuel de \textit{JI}.


\section{Recommandation et justification de la technique de planification}
% Erick
% 3 pages
L'analyse des différentes techniques de planification a permis de faire ressortir les éléments suivants.  Cependant, étant donné que le choix de la technique de planification est indépendant du choix de la technique de recherche qui l'implémente, ces deux sujets seront traités séparément.

\subsection{Techniques de planification}
Dans les deux cas,il s'agit de trouver une séquence d'action qui permettent d'atteindre un but. Dans le cas de la planification de la recherche par espace d'état, la recherche s'effectue sur l'état de l'environnement de jeu alors que dans le cas de la planification partiellement ordonnée, la recherche s'effectue sur l'environnement d'actions, c'est-à-dire les actions et leur dépendances mutuelles. 

\subsubsection{Planification par recherche d'espace d'état}

La planification par recherche d'espace d'état est la plus simple à mettre en oeuvre puisqu'elle est conceptuellement très similaire au comportement de l'agent dans la situation réelle.  Il s'agit en quelque sorte d'essayer différent plan possible et d'observer l'évolution de l'environnement pour chacun de ces plans jusqu'à ce que l'on obtienne l'état désiré.  Il est possible de faire la recherche par chaînage avant ou arrière en s'appuyant sur les préconditions et les effets des différentes actions possibles.

Il a été constaté que le chaînage arrière peut éliminer, pour certaines classes de problèmes, l'exploration de branches dans l'arbre de recherche qui ne mènent pas à la solution.  Cependant, dans le cas du jeu \textit{BlockBlitz}, la difficulté de spécifier complètement et adéquatement la configuration finale de l'environnement de jeu pour atteindre le but ``Avoir un bloc'' rend très difficile l'application du chaînage arrière.

Le chaînage avant est plus aisé dans notre cas puisque la situation initiale du point de vue de l'arbre de recherche est une situation complètement connue puisque l'environnement de jeu est complètement spécifié et passé au joueur à chaque tour de jeu.

Finalement, dans le cas de la recherche par espace d'état, la recherche d'un heuristique valide dans le cas d'un but composé de plusieurs conditions demande un peu de fignolage car il faut toujours s'assurer que l'heuristique ne surestime pas le coût d'une action.  Pour cela, il est possible d'appliquer l'hypothèse de l'indépendance des sous-buts ou de relâcher les conditions du problème.  Comme le but choisi pour l'intelligence du joueur était unique, nous ne nous sommes pas attardé davantage sur cette question.

\subsubsection{Planification partiellement ordonnée}

La planification partiellement ordonnée est une technique un peu plus sophistiquée, qui tente de manipuler la structure logique du problème pour en dériver un plan.  Ce faisant, il est alors possible de trouver une série d'action et leurs dépendances sans que cette description prescrive une série d'action \textit{unique}.  Cela est possible en raisonnant \textit{exclusivement} sur les préconditions et les effets des actions, sans tenir compte de l'ensemble de l'environnement.

Cette technique permet une plus grande flexibilité dans l'exécution du plan puisqu'une contrainte inconnue au moment de l'élaboration du plan peut être gérée adéquatement en effectuant un choix parmi les actions possibles au moment de l'exécution.  De plus, l'élaboration du plan pourrait potentiellement être plus efficace si l'espace de recherche sur les actions est moindre que sur les environnement de jeu potentiels.

Cependant, cette technique est plus difficile à appliquer dans le cas où les préconditions ou effets des actions sont représentées avec des variables.  De plus, l'établissement d'heuristiques pour la planification partielle n'est pas un domaine complètement compris.

\subsection{Techniques de recherche}
Les techniques de recherche analysées se répartissent en deux grandes catégories, informées ou non-informées, selon qu'elles utilisent ou non un heuristique pour guider la recherche.  De plus, l'utilisation d'une liste fermée ou non détermine si on effectue un parcours d'arbre ou de graphe et peut influer de fa\c con significative sur l'utilisation mémoire.  Étant donné le temps de développement disponible pour la réalisation de cette analyse, seul les algorithmes de parcours de graphe ont été considérés.  De plus, en première analyse, nous n'avons pas tenté d'analyser la complexité des structures de données utilisées pour implémenter chacun des algorithmes mais seul la complexité de l'algorithme lui même a été étudiée.  Pour une analyse plus exhaustive, il faudrait en tenir compte.

\subsubsection{Recherche non-informée}
Les algorithmes de recherche non-informée font l'équivalent d'une recherche à l'aveugle au sens où l'algorithme ne possède aucun indicateur lui permettant de déterminer s'il se rapproche du but pendant la recherche.  Puisqu'il était très simple de tester différents algorithmes en changeant les structures de données utilisées, la recherche en largeur, la recherche en profondeur et la recherche par coût uniforme ont été testées.

Dans les trois cas, en tenant compte de l'utilisation d'une liste fermée, les algorithmes sont complets, au sens où ils vont tous trouver une solution s'il en existe une. À noter que la recherche en profondeur d'abord n'est pas complète sans l'utilisation d'une liste fermée puisqu'elle peut se retrouver dans une branche de profondeur infinie.

Cependant, seuls la recherche en largeur et la recherche à coût uniforme garantissent un résultat optimal, c'est-à-dire que la solution trouvée aura le moindre coût de toutes les solutions possibles. Cela au prix d'une utilisation mémoire beaucoup plus importante que pour la recherche en profondeur d'abord.

Dans tous les cas, l'analyse en complexité permet de mettre en lumière que l'explosion combinatoire des états à explorer dans la recherche non-informée la rend impraticable dans le cas où l'espace de recherche est plus que modeste.  

\subsubsection{Recherche informée}
La recherche informée utilise quant à elle une mesure approximative de rapprochement du but. Pour cette analyse, l'étude s'est limitée à la comparaison des algorithmes de recherche non-informée avec les algorithmes avare et A*.

Dans le cas de la recherche avare, seule la mesure de rapprochement du but à l'aide de l'heuristique est évaluée pour le choix du prochain noeud à explorer.  Cela a pour conséquence que la recherche avare est non-optimale et incomplète.

Dans le cas de la recherche A*, le total du coût du parcours et de la valeur de l'heuristique sont pris en compte pour le choix du prochain noeud à explorer.  Cela est suffisant pour assurer la complétude et l'optimalité.

Dans les deux cas, le choix de l'heuristique est primordial pour le bon fonctionnement des algorithmes.  Celle-ci ne doit jamais surestimer le coût d'une action.  Cela peut être très payant au bout du compte puisque qu'une section beaucoup plus restreinte de l'arbre de recherche doit être explorée.  En première analyse, cela rend les algorithmes de recherche beaucoup plus attrayant.  Encore une fois, il faut cependant tenir compte de la complexité des opérations sur les structures de données utilisées pour mesurer l'efficacité d'une implémentation ainsi que le coût de calcul de l'heuristique.  

Finalement, le choix de la technique de recherche doit être réalisé en fonction des paramètre du problème, notamment la taille de l'espace de recherche, les contraintes d'utilisation mémoire et de temps processeur et l'importance d'avoir un plan optimal. 


\subsection{Choix de la technique}

Étant donné les éléments mentionnés plus haut, nous avons choisi d'utiliser la planification par recherche d'espace d'état pour la simplicité de l'implémentation et du choix de l'heuristique et à la lumière à la fois de l'analyse réalisée et des tests d'implémentation nous avons choisi la technique de recherche par % À compléter 
pour l'implémentation de la planification.

\section{Resultats de tests}
% Alex et Erick
% 3 pages

% Criteres
% - Temps de calcul
% - Qualite du plan
% - Complexite de developement

% - Couvrir les algorithmes de recherche informee et non-informee

Afin de sélectionner la bonne méthode de recherche, nous avons fixé deux critères. Le premier et le temps de calcul et le second est la qualité du plan. Il va de soit qu'il faut trouvé un compromis entre le temps et le compromis. Nous allons négliger la mémoire car nous n'avons trouvé de moyen de calculer la consomation maximale de l'algorithme dans l'interpréteur prolog. Nous avons aussi négliger la compxité du développement car chaque méthode est sensiblement identique. La seul implémentation qui varie est l'ajout et le retrait d'un noeud de la liste ouvert.

Pour ce qui est du classement par rapport à la qualité du plan, la théorie nous indique une ordre à deux niveau. C'est à dire ceux qui sont optimal et ceux qui ne le sont pas nécéssairement.

\begin{center}
  \begin{tabular}{@{} cc @{}}
    \hline
    Méthodes absolument optimals & Méthode possiblement optimals\\ 
    \hline
    A* & Avare\\     
    Coût uniforme & Largeur d'abord \\
    &Profondeur d'abord\\
    \hline
  \end{tabular}
\end{center}

La méthode de largeur d'abord n'est pas nécéssairement optimal dans notre cas car chaque actions possible n'a pas le même coût.

Voici maintenant un graphique démontrant le temps d'exécution pour chacune des cinq méthodes précédement présenté. Chaque colone est l'exécution d'un test qui possède un environnement plus grand. Voici les environnement que nous avons utilisé pour effectuer nos tests de performances:

\begin{itemize}
\item 
\textbf{Environnement 1} :- 
[5, 10, 15, 15, [[1,'Inconnu1',7,7,0], [2,'Inconnu2',8,10,13], [3,'Inconnu3',2,0,15], [4,'Inconnu4',1,10,1], [5,Nom,10,12,0]], [[2,12,10], [3,7,0], [4,2,4], [5,12,14], [6,14,10], [7,7,4], [8,10,3]]]
\item 
\textbf{Environnement 2} :- 
[5, 10, 25, 25, [[1,Nom,10,16,0], [2,'Inconnu2',7,23,0], [3,'Inconnu3',8,9,0], [4,'Inconnu4',0,5,0], [5,'Inconnu5',4,16,3]], [[1,17,13], [2,20,2], [4,5,3], [5,4,14], [6,14,10], [7,18,17], [8,20,21], [9,15,5], [10,4,15]]]
\item 
\textbf{Environnement 3} :- 
[5, 10, 50, 50, [[1,'Inconnu1',13,26,0], [2,'Inconnu2',43,44,0], [3,Nom,10,16,0], [4,'Inconnu4',1,32,0], [5,'Inconnu5',16,16,16]], [[1,17,13], [2,20,2], [4,5,3], [5,4,14], [6,14,10], [7,18,17], [8,20,21], [9,15,5], [10,4,15]]]
\item 
\textbf{Environnement 4} :- 
[5, 10, 75, 75, [[1,'Inconnu1',38,14,0], [2,'Inconnu2',45,39,0], [3,'Inconnu3',31,60,0], [4,Nom,10,16,0], [5,'Inconnu5',13,35,12]], [[1,5,0], [2,52,61], [3,3,48], [4,7,27], [5,23,17], [6,28,29], [7,55,21], [8,12,0], [9,64,48]]]
\end{itemize}


\begin{figure}[!h] %on ouvre l'environnement figure
\includegraphics[width=4in]{resultats-planif} %ou image.png, .jpeg etc.
\caption{Progression du temps de calcul pour différents algorithmes pour différents environnements} 
\end{figure}


\section{Representation STRIPS ou ADL des actions possibles de BlockBlitz}
% Erick 
% 1.5 pages
Par soucis de concision et de lisibilité, l'environnement de jeu initial et l'environnement de jeu final seront omis des paramètres, des préconditions et des effets des actions présentées bien qu'ils soient utilisés de fa\c con explicite dans le programme remis.  Pour l'ensemble des actions présentées, nous assumerons un environnement de jeu composé des faits suivants, les multiplicités présentées représentent le nombre de faits distincts du type présenté pouvant être retrouvés dans l'environnement, ex: nbJoueur(N), 1 signifie qu'un seul fait de type nbJoueur est présent dans l'environnement et block(...), 1+ signifie que chaque bloc est représenté par son propre fait et qu'il y en a autant que de blocs.

\begin{center}
  \begin{tabular}{@{} ccc @{}}
    \hline
    Fait & Multiplicité & Signification \\ 
    \hline
    NbJoueur(n) & 1 & $n$ est le nombre de joueurs \\ 
    NbBlock(n) & 1 & $n$ est le nombre de blocks \\ 
    NbColonnes(n) & 1 & $n$ est le nombre de colonnes \\ 
    NbRangees(n) & 1 & $n$ est le nombre de rangées \\ 
    Block(id,x,y) & 1+ & $id$ est la valeur du block, \\
                                  && $x$ est la position en selon $x$ \\
                                  && et $y$ est la position selon $y$ \\ 
    Player(id,nom,x,y,blockId) & 1+ & $id$ est l'identifiant unique du joueur \\
                                                              && $nom$ est le nom assigné au joueur \\ 
                                                              && $x$ est la position selon $x$ \\
                                                              && $y$ est la position selon $y$ \\
                                                              && $blockId$ est l'identifiant du bloc possédé par le joueur\\
    Nom(nom) & 1 & $nom$ est le nom du joueur \\ 
    \hline
  \end{tabular}
\end{center}

En plus de ces faits de base, les prédicats suivants sont utilisés pour faciliter l'expression des préconditions et des effets. \\
\\
Il est nécessaire de traduire la direction en coordonnées. Pour ce faire, le prédicat $Direction(posx,posy,newx,newy,direction)$ est utilisé pour déterminer la nouvelle position du joueur à partir de sa position précédente.  Il y a huit entrées pour chacune des direction.  L'entrée pour la direction $1$ est la suivante, les autres entrées sont laissées comme exercice au lecteur.
\begin{equation*}
	Direction(posx,posy,newx,newy, 1) \Leftarrow newy = posy + 1 \wedge newx = posx 
\end{equation*}

Les deux derniers prédicats sont les suivants.  $Empty(posx,posy)$ assure que la case visée ne contient rien, c'est-à-dire aucun joueur ou bloc, et $Exist(posx,posy)$ valide que la case visée appartient bel et bien à l'environnement, c'est-à-dire qu'elle est contenue dans ses limites.
\begin{eqnarray*}
	Empty(posx,posy) \Leftarrow & \lnot Block(\_,posx,posy)  \wedge \lnot Player(\_,\_,posx,posy,\_) \\
	Exist(posx,posy) \Leftarrow & posx  \geq 0 \wedge posy \geq 0 \\
	                                                    \wedge & NbColonnes(nbColonnes)  \wedge NbRangees(nbRangees) \\
	                                                   \wedge & posx < nbColonnes \wedge posy < nbRangees 
\end{eqnarray*}

Il est alors très aisé d'exprimer les préconditions et les effets de chacune des actions.

\begin{tabbing}
\textit{Action}\=\textit{(Move(direction))}\=,\\
\> PRECOND: \> $Nom(nom) \wedge Player(id,nom,posx,posy,blockid)$ \\ 
\> \> $  \wedge \ Direction(posx,posy,newx,newy,direction) $ \\
\> \> $   \wedge \ Exist(newx,newy) \wedge Empty(newx,newy) $ \\               
\> EFFECT: \>$ \lnot Player(id,nom,posx,posy,blockid) $ \\
\>  \> $\wedge\ Player(id,nom,newx,newy,blockid)$ .\\
\end{tabbing}

Pour le cas où le joueur ne possède pas de bloc, l'action $take$ est la suivante:

\begin{tabbing}
\textit{Action}\=\textit{(Take(direction))}\=,\\
\> PRECOND: \> $Nom(nom) \wedge Player(id,nom,posx,posy,0)$ \\ 
\> \> $  \wedge \ Direction(posx,posy,newx,newy,direction) $ \\
\> \> $   \wedge \ Exist(newx,newy) \wedge Block(newblockid,newx,newy) $ \\               
\> EFFECT: \>$ \lnot Player(id,nom,posx,posy,0) $ \\
\>  \> $\wedge\ Player(id,nom,newx,newy,newblockid)$ \\
\> \> $\wedge\ \lnot Block(newblockid,newx,newy) $ .\\
\end{tabbing}

Pour le cas où le joueur possède déjà un bloc, l'action $take$ est plutôt:
\begin{tabbing}
\textit{Action}\=\textit{(Take(direction))}\=,\\
\> PRECOND: \> $Nom(nom) \wedge Player(id,nom,posx,posy,blockid)$ \\ 
\> \> $  \wedge \ Direction(posx,posy,newx,newy,direction) $ \\
\> \> $   \wedge \ Exist(newx,newy) \wedge Block(newblockid,newx,newy) $ \\               
\> EFFECT: \>$ \lnot Player(id,nom,posx,posy,blockid) $ \\
\>  \> $\wedge\ Player(id,nom,newx,newy,newblockid)$ \\
\> \> $\wedge\ \lnot Block(newblockid,newx,newy) $ \\
\> \> $\wedge\ Block(blockid,newx,newy) $ .\\
\end{tabbing}

\begin{tabbing}
\textit{Action}\=\textit{(Drop(direction))}\=,\\
\> PRECOND: \> $Nom(nom) \wedge Player(id,nom,posx,posy,blockid)$ \\ 
\> \> $  \wedge \  \lnot Player(id,nom,posx,posy,0) $ \\
\> \> $  \wedge \ Direction(posx,posy,newx,newy,direction) $ \\
\> \> $   \wedge \ Exist(newx,newy) \wedge Empty(newx,newy) $ \\               
\> EFFECT: \>$ \lnot Player(id,nom,posx,posy,blockid) $ \\
\>  \> $\wedge\ Player(id,nom,posx,posy,0)$ \\
\> \> $\wedge\ Block(blockid,newx,newy) $ .\\
\end{tabbing}

Bien que la problématique présente deux cas distincts pour l'attaque, avec la représentation proposée, la même description s'applique dans les deux cas (joueur possède ou non un bloc).  De plus, pour fins de planification, nous allons considérer que l'action réussi toujours.:

\begin{tabbing}
\textit{Action}\=\textit{(Attack(direction))}\=,\\
\> PRECOND: \> $Nom(nom) \wedge Player(id,nom,posx,posy,blockid)$ \\ 
\> \> $  \wedge \ Direction(posx,posy,newx,newy,direction) $ \\
\> \> $  \wedge \ Player(id2,nom2,newx,newy,blockid2) $ \\
\> \> $  \wedge \ \lnot Player(id2,nom2,newx,newy,0) $ \\
\> \> $ \wedge\ \lnot Block(bid,newx,newy) \wedge \ Exist(newx,newy)$ \\               
\> EFFECT: \>$ \lnot Player(id,nom,posx,posy,blockid) $ \\
\>  \> $\wedge\ Player(id,nom,posx,posy,blockid2)$ \\
\>  \> $\wedge\ \lnot Player(id2,nom2,newx,newy,blockid2)$ \\
\>  \> $\wedge\ Player(id2,nom2,newx,newy,blockid)$ .\\
\end{tabbing}

Finalement, l'action $None$ ne possède aucune précondition et n'a aucun effet sur l'environnement.

\section{Description et une explication du vocabulaire des parties principales de la solution}

\section{Description de parties principales de notre solution}
% Alex
% 1 page
La particularité principale que nou avons implémenté dans notre solution est la méthode généralisé du parcours de graphe. Tout en respectant les méthodes de la logique de première ordre, nous avons transcrit litéralement l'algorithme. C'est à dire que nous ne forçons pas une structure de donnée à l'intérieur de l'algorithme. Nous avons procédé ainsi puisque cette algorithme est noyau de tous les méthodes de recherches que nous avons utilisé (\textit{profondeur d'abord, largeur d'abord, coût uniforme, avare et A*}). C'est d'ailleurs ainsi que nous sommes parvenu à comparer rapidement les performances de ces cinqs techniques.

Voici les structures de données que nous avons utilisé dans notre implémentation de planification.

\begin{itemize}
\item \textbf{Node} : \textit{node(Etat,NoeudParent,Action,Profondeur,Cout)}
\item \textbf{Action} : \textit{action(Action,Etat, Cout, EtatResultant, CoutResultant)}
\end{itemize}

Le \textbf{Node} est l'élément qui représente le graphe que l'algorithme de recherche parcours. L'\textbf{Action}, tel que présenté à la section de la représentation STRIPS des actions possible de \textit{BlockBlitz}, valide d'abord si le mouvement peut être effectuer sur l'environnement. Nous avons cependant explicitement partager un environnement aulieu d'utiliser la base de connaissance de l'interpréteur prolog. L'environnement est représenté par la variable \textit{Etat}. De plus, si l'action est effectivement valide, nous retournons l'environnement résultant ainsi que le nouveau coût qui est relié au parcous effectué.

Avec notre représentation, nous avons pu effectué l'expansion de nos noeuds lors du parcours de graphe de façon efficace. Dans le cas de \textit{BlockBlitz}, l'expansion signifie de trouvé la prochaine action à effectuer. Nous avons donc utilisé la fonction \textit{findall} avec comme objectif le predicat avec seulment l'état et le cout comme variable assigné. Celà nous donne alors la liste des noeuds succésseurs avec leur nouvelles environnement déjà construite ainsi que le cout de l'action. C'est la fonction \textit{findall} qui, avec l'inférence et le fait de trouvé un action valide, retourne le nouveau cout et l'environnement résultant et l'ajoute à la liste résultante.


\section{Recommandation de la pertinence des methodes d'algorithme évolué}
% Alex
% 1 page

% Planification continuelle, multiagent, conditionnelle
Dans le cadre de notre analyse nous avons également survolé des techniques de planification plus évoluées, c'est-à-dire des techniques pour lesquelles les hypothèses sur l'environnement de jeu sont moins restrictives.  La recherche classique telle qu'envisagée précédemment assume que l'environnement est pleinement observable, statique et déterministe et que les actions affectant l'environnement sont correctes et complètes. Ces hypothèses permettent de réaliser la planification beaucoup plus simplement.
Dans le cas du jeu \textit{BlockBlitz}, pour que l'IA se comporte de fa\c con optimale, ces hypothèses sont trop restrictives puisque nous n'avons pas affaire à un environnement statique et nous sommes en présence d'autres agents compétiteurs.  Il est donc pertinent d'évaluer les techniques de planification plus avancées.  Les caractéristiques de chacune de ces techniques sont brièvement abordées ci-après ainsi que leur applicabilité au jeu \textit{BlockBlitz}.

\subsection{Planification conditionnelle}
La planification conditionnelle tente de gérer l'incertitude liée à un environnement non-déterministe en vérifiant à différent points du plan que certaines conditions sont vraies et tente d'apporter un plan de contingence pour les différents scénarios possibles.

Dans notre cas, la planification conditonnelle n'est pas vraiment intéressante puisque l'environnement est déterministe.  Cette technique ne sera donc pas discutée davantage.

\subsection{Replanification et observation de l'exécution du plan}
La replanification consiste à vérifier au fur et à mesure de l'exécution du plan que celui-ci est encore valide.  Cela peut être fait une action à la fois ou bien pour l'ensemble du plan à chaque étape.  Lorsque les conditions d'applicabilité du plan ne sont plus valides, il est alors possible d'en générer un nouveau. Cela est très approprié dans le cas d'un environnement dynamique.

Cette technique est parfaitement applicable au jeu \textit{BlockBlitz}, et nous l'avons d'ailleurs utilisée avec succès puisque la présence d'autres agents dans le jeu modifie l'environnement pendant l'exécution du plan, le rendant dynamique.  Nous validons à chaque tour la validité du plan avant de fournir la prochaine action.

\subsection{Planification multiagent}

La planification multi-agents tient compte des autres agents actifs dans l'environnement pour l'établissement des plans.  Dans le cas du jeu \textit{BlockBlitz}, il s'agit d'une situation compétitive où les autres agents tentent d'accomplir leur(s) but(s) au détriment ou non de leurs adversaires.  Pour être utilisable, l'IA doit générer des plans pour les autres joueurs et en tenir compte dans l'établissement de son propre plan.  Cela rend la complexité de la recherche beaucoup plus importante et implique un domaine de recherche nommé la théorie des jeux.  Étant donné la complexité cela n'a pas été abordé dans le cadre de cette analyse.  

Cependant, pour réaliser un IA convainquant et intéressant pour le jeu il est nécessaire que celui-ci applique ce type de technique et dans le cadre d'une stratégie de développement de jeu plus global cela vaudrait la peine de s'attarder à comprendre et appliquer cette technique.


\section{Conclusion}
% Alex
% 0.5 page

\end{document}